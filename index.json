{
  "api/index.html": {
    "href": "api/index.html",
    "title": "Reliance Thermal Printer API",
    "keywords": "Reliance Thermal Printer API This library was designed so that the majority of your tasks can be completed with a single using statement We recommend that your create your <xref:PTIRelianceLib.ReliancePrinter> on as as-needed basis. That means we do not recommend keeping your printer as a field or property inside your class. public class MyApplication { // Don't do this!! private IPyramidDevice _mPrinter; // Or this!! public ReliancePrinter Printer { get; private set;} // But do this public void DoPrinterThings(MyData data) { // Printer is automatically discovered and connected using(var printer = new ReliancePrinter() { var stuff = data.GetStuff(); ... // Proceed to work with printer } } } You can also do some cool things with the data types we provide such as <xref:PTIRelianceLib.Status> and <xref:PTIRelianceLib.Revlev>. They are automatically disposable so you are free to bind to their properties without having to worry about memory leaks."
  },
  "tutorials/telemetry.html": {
    "href": "tutorials/telemetry.html",
    "title": "Telemetry",
    "keywords": "Telemetry The Reliance Thermal printer tracks the metrics that matter. We have counters for just about any even you can imagine and they are all accessible through this API. With this information, you can track paper consumption, ticket pull habits, error patterns, and many other metrics. There are two groups for telemetry: Lifetime : This is a cumulative record of all events since the printer left our factory. Powerup : This is a record of all events since the last power cycle. See <xref:PTIRelianceLib.Telemetry.LifetimeTelemetry> and <xref:PTIRelianceLib.Telemetry.PowerupTelemetry> for more details. Warning Require Firmware 1.28+. Calling this API on older firmware will return null. Ticket Pull The best way to detect a ticket pull is request the telemetry information and inspect the <xref:PTIRelianceLib.Telemetry.LastTicketState> property. This records the most recent action taken on a printed ticket along with the ticket's length in millimeters. We recommend that you do not poll the printer more than 4 times a second in order to prevent unecessary blocking read requests. After a ticket is printed, poll the printer about once a second and watch for the TicketCount property to increment. Once it increments, you can read the LastTicketState property and examine how the ticket was handled. Ticket Lengths Tickets lengths are tracked by binning ticket lengths into 9 groups. The exact lengths groups are enumerated in <xref:PTIRelianceLib.Telemetry.TicketLengthGroups> in millimeters. The telemetry object tracks the count of each ticket by these groups. All tickets with the exception of startup and push-button diagnostic tickets are counted in this metric. Ticket Pull Time Tickets pull time is the time in second it took for a customer to pull the ticket from the printer. If a ticket is never pulled and is instead ejected or retracted, no measurement will be taken. The exact time groups are enumerated in <xref:PTIRelianceLib.Telemetry.TicketPullTimeGroups> in second. Code Sample using System; using System.Collections.Generic; using System.Threading; using PTIRelianceLib; using Newtonsoft.Json; using Newtonsoft.Json.Converters; namespace reliance_sample { class Program { static void Main(string[] args) { // Wrap our printer in using so it gets disposed on properly using (var printer = new ReliancePrinter()) { var tel1 = printer.GetPowerupTelemetry(); var str = JsonConvert.SerializeObject(tel1, Formatting.Indented, new StringEnumConverter()); Console.WriteLine(\"Powerup Telementry:\\n{0}\", str); var tel2 = printer.GetLifetimeTelemetry(); var str = JsonConvert.SerializeObject(tel2, Formatting.Indented, new StringEnumConverter()); Console.WriteLine(\"Lifetime Telementry:\\n{0}\", str); } } } } Warning Exceptions For clarity, exception handling has been elided. It is advisable to wrap any ReliancePrinter method calls in a try/catch block for <xref:PTIRelianceLib.PTIException>."
  },
  "tutorials/status_check.html": {
    "href": "tutorials/status_check.html",
    "title": "Checking Printer Status",
    "keywords": "Checking Printer Status Your Reliance printer can report errors in a number ways. This tutorial demonstrates how to use the method built into this library. It is easier to use that the ESC/POS version and is not OS-depdendent like the C++ version . Code Sample using System; using PTIRelianceLib; namespace reliance_sample { class Program { static void Main(string[] args) { // Wrap our printer in using so it gets disposed on properly using(var printer = new ReliancePrinter()) { // Get the status! var status = printer.GetStatus(); // Print the summary in a block of text Console.WriteLine(\"Printer status:\\n{0}\", status); // We can also get more specific details var jammed = status.PrinterErrors.HasFlag(ErrorStatuses.Jammed); Console.WriteLine(\"Printer Jammed? :{0}\", jammed); var lidOpen = status.PrinterErrors.HasFlag(ErrorStatuses.PlatenOpen); Console.WriteLine(\"Lid Open? :{0}\", lidOpen); var hasPaper = status.SensorStatus.HasFlag(SensorStatuses.Path); Console.WriteLine(\"Has Paper? :{0}\", hasPaper); // You can also check the status of the Ticket (e.g. Ticket Pull) var ticketState = status.TicketStatus; Console.WriteLine(\"Ticket State :{0}\", ticketState); } } } } Warning Exceptions For clarity, exception handling has been elided. It is advisable to wrap any ReliancePrinter method calls in a try/catch block for <xref:PTIRelianceLib.PTIException>."
  },
  "tutorials/exceptions.html": {
    "href": "tutorials/exceptions.html",
    "title": "Exceptions",
    "keywords": "Warning Exceptions For clarity, exception handling has been elided. It is advisable to wrap any ReliancePrinter method calls in a try/catch block for <xref:PTIRelianceLib.PTIException>."
  },
  "tutorials/configuration.html": {
    "href": "tutorials/configuration.html",
    "title": "Device Configuration",
    "keywords": "Device Configuration Configuration can be managed through this API with use of Reliance RFG configuration files. The workflow for generating this files is to use Reliance Tools for PC to configure your printer to your desired settings. When ready, click File->Save Config and select where to save your file. The file will have the RFG file extension. Getting a Config Code Once you have an RFG file, you have a few options for getting it into your application. The most straightforward method is to use <xref:PTIRelianceLib.BinaryFile.From*>. Code Sample using System; using PTIRelianceLib; namespace reliance_sample { class Program { static void Main(string[] args) { // Load a firmware file someplace on disk var file = BinaryFile.From(\"my_config.rfg\"); // Make sure that file loaded okay if (file.Empty) { Console.WriteLine(\"Configuration file cannot be read. Does it exist?\"); } else { // Wrap our printer in using so it gets disposed on properly using(var printer = new ReliancePrinter()) { // Do the config! var result = printer.SendConfiguration(file); Console.WriteLine(\"\\nConfiguration Update Result: {0}\", result); } } } } } Warning Exceptions For clarity, exception handling has been elided. It is advisable to wrap any ReliancePrinter method calls in a try/catch block for <xref:PTIRelianceLib.PTIException>."
  },
  "tutorials/customization.html": {
    "href": "tutorials/customization.html",
    "title": "Library Customization",
    "keywords": "Library Customization PTIRelianceLib is designed to support as many operating systems as possible. We try to support as much as possible with defaults but in some cases, there are outliers that we need to make special accommodations for without affecting other systems. These options are accessible in the <xref:PTIRelianceLib.LibraryOptions> class and should be attached to the global <xref:PTIRelianceLib.Library>. Connection Failures The most common issue users experience with hardware SDKs is with the initial connection. This can be due to driver issues, operating system configuration, or many other possibilities. In this library, there are two likely causes for your connection issue. 1 Incorrect native library version: We use HIDAPI to access the Reliance Printer as a HID USB device. Our nuget package installs the native library for Windows(x86 and x64), Linux x64, ans OSX x64. If you use a different CPU or operating system, your environment is not supported at this time. Contact us! 2 Your operating system is not propagating device information in a standard way. This is common in Docker containers. If your system is supported and you've followed all the tutorials, read on to learn how to customize PTIRelianceLib for your environment. Options <xref:PTIRelianceLib.LibraryOptions> provides following properties: HidCleanupDelayMs: Used to ensure operating system is given enough time to remove and create device handles HidReconnectDelayMs: Used to give the operating system more time to enumerate devices during reconnection HidFlushStructuresOnEnumError: When no devices are found during enumeration, this may indicate stale device data is being forwarded by your system. Set this flag to force receipt of fresh information. Relation to Flash Update The Reliance Thermal Printer executes a reboot at the start and end of the flash update process. This generates USB disconnect and reconnect events which, as stated above, can be tricky on some systems. If you are having trouble flash updating for your system, take as look at some of the preconfigured settings available in <xref:PTIRelianceLib.LibraryOptions> such as DockerLinuxStretch. Warning Exceptions For clarity, exception handling has been elided. It is advisable to wrap any ReliancePrinter method calls in a try/catch block for <xref:PTIRelianceLib.PTIException>."
  },
  "index.html": {
    "href": "index.html",
    "title": "PTI.Reliance.Tools",
    "keywords": "PTI.Reliance.Tools A cross-platform .NET Core 2.0 API for updating and maintaining your Reliance Thermal Printer . Source code available on Github Quick Start Check out the tutorials to get started quickly. Deep Dive For details on the core library, see <xref:PTIRelianceLib>"
  },
  "tutorials/logos.html": {
    "href": "tutorials/logos.html",
    "title": "Logos",
    "keywords": "Logos This API makes storing logos in your internal flash very easy. With this API, you can dither, resize, and store any image into internal flash for fast printing. There are a number of dithering algorithms ready for you to try. Use the one that makes your image look the best! See the <xref:PTIRelianceLib.Imaging.DitherAlgorithms> list and <xref:PTIRelianceLib.Imaging.LogoStorageConfig> for more details. Code Sample using System; using System.Collections.Generic; using System.Threading; using PTIRelianceLib; using PTIRelianceLib.Imaging; namespace reliance_sample { class Program { static void Main(string[] args) { // Wrap our printer in using so it gets disposed on properly using (var printer = new ReliancePrinter()) { var logos = new List<BinaryFile> { BinaryFile.From(\"index.jpg\"), BinaryFile.From(\"index2.jpg\"), }; var config = LogoStorageConfig.Default; config.Algorithm = DitherAlgorithms.Atkinson; var result = printer.StoreLogos(logos, new DevNullMonitor(), config); Console.WriteLine(\"Write Result: {0}\", result); // use logo index to recall and print for(int i = 0 ; i < logos.Count; ++i) { printer.PrintLogo(i); // Give ~3 seconds to print Thread.Sleep(3 * 1000); } } } } } Warning Exceptions For clarity, exception handling has been elided. It is advisable to wrap any ReliancePrinter method calls in a try/catch block for <xref:PTIRelianceLib.PTIException>."
  },
  "tutorials/logging.html": {
    "href": "tutorials/logging.html",
    "title": "Logging",
    "keywords": "Logging PTIRelianceLig uses a the framework agnostic logging library LibLog . Integrating with your application is simple and we use NLog throughout the sample projects. NLog Setup Install NLog dotnet add package NLog.Config Add a config file named NLog.config to the root of your application. This is typically next to your csproj file. Here is a sample config file: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"> <targets> <target name=\"logfile\" xsi:type=\"File\" fileName=\"MyApplication.log\" /> <target name=\"logconsole\" xsi:type=\"Console\" /> </targets> <rules> <logger name=\"*\" minlevel=\"Debug\" writeTo=\"logconsole\" /> <logger name=\"*\" minlevel=\"Trace\" writeTo=\"logfile\" /> </rules> </nlog> Other Frameworks See LibLog's sample directory"
  },
  "tutorials/intro.html": {
    "href": "tutorials/intro.html",
    "title": "Getting Started",
    "keywords": "Getting Started Install .NET Core SDK for your operating system Open your favorite terminal Setup Project and install library dotnet new console -o reliance_sample cd reliance_sample dotnet add package PTIRelianceLib Open Program.cs in your favorite editor and replace the code with the following: using System; using PTIRelianceLib; namespace reliance_sample { class Program { static void Main(string[] args) { using(var printer = new ReliancePrinter()) { var rev = printer.GetFirmwareRevision(); Console.WriteLine(\"Firmware revision: {0}\", rev); } } } } Important Linux users, please make sure libusb is installed before proceeding Execute dotnet run Results"
  },
  "tutorials/flash_update.html": {
    "href": "tutorials/flash_update.html",
    "title": "Firmware Flash Updates",
    "keywords": "Firmware Flash Updates This library is designed promote natural use of good design practices. One of the most important patterns you will see in the samples, tests, and the core library itself is extensive using of the using pattern. Following this design will prevent common causes of memory leaks while making your code easier to maintain. Code that is easy maintain gives you more time to focus on the features that bring value to your product. Code Sample using System; using PTIRelianceLib; namespace reliance_sample { class Program { static void Main(string[] args) { // Load a firmware file someplace on disk var file = BinaryFile.From(\"reliance_1.27.171.ptix\"); // Make sure that file loaded okay if (file.Empty) { Console.WriteLine(\"Firmware file cannot be read. Does it exist?\"); } else { // You could also use a DevNullMonitor if you want to ignore output entirely var monitor = new ProgressMonitor(); monitor.OnFlashMessage += (s, o) => Console.WriteLine(\"\\n{0}\", o.Message); // Simple progress monitor monitor.OnFlashProgressUpdated += (s, o) => { Console.CursorLeft = 0; Console.CursorVisible = false; Console.Write(\"{0:0.00}%\", o.Progress*100); }; // Wrap our printer in using so it gets disposed on properly using(var printer = new ReliancePrinter()) { // Do the update! var result = printer.FlashUpdateTarget(file, monitor); Console.WriteLine(\"\\nFlash Update Result: {0}\", result); } } } } } Warning Exceptions For clarity, exception handling has been elided. It is advisable to wrap any ReliancePrinter method calls in a try/catch block for <xref:PTIRelianceLib.PTIException>. Tip Flash udpating may be unreliable on Docker. See the Docker section for more details."
  },
  "tutorials/docker.html": {
    "href": "tutorials/docker.html",
    "title": "Docker Support",
    "keywords": "Docker Support The abstraction mechanisms of Docker make certain types of hardware integration quite challenging in Docker. As long as your device is not removed and reinserted during the lifetime of your container you will likely not have any issues. However, certain operations like our flash update process generate USB reset event that will confound Docker. This tutorial explains solutions for this particular problem. Important Only Linux hosts are supported for Docker containers Privileged The most reliable implementation we've tested leverages the --privileged flag and the mounting of /dev/bus/usb volume from host to container. Your results may vary and you may find this to be unnecessary for your environment. sudo docker run --rm -it \\ -v /dev/bus/usb:/dev/bus/usb \\ --privileged \\ <YOUR_CONTAINER>:<VERSION> Host Permissions Your host system may require additional permissions or even udev rules in order to reliably attach to your Reliance Thermal Printer. This is typically achieved by adding your user to the dialout group or equivalent for your environment. Another option is to create a udev rule, /etc/udev/rules.d/99-udev.rules with the following contents. # Reliance Thermal Printer HID interface SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0425\", ATTRS{idProduct}==\"8147\", MODE=\"0666\" Special Configurations A pre-made configuration for the Debian Stretch Docker image can be configured with the following in your application start up code. PTIRelianceLib.Library.Options = PTIRelianceLib.LibraryOptions.DockerLinuxStretch; Library Customization PTIRelianceLib is designed to support as many operating systems as possible. We try to support as much as possible with defaults but in some cases, there are outliers that we need to make special accommodations for without affecting other systems. These options are accessible in the <xref:PTIRelianceLib.LibraryOptions> class and should be attached to the global <xref:PTIRelianceLib.Library>. Connection Failures The most common issue users experience with hardware SDKs is with the initial connection. This can be due to driver issues, operating system configuration, or many other possibilities. In this library, there are two likely causes for your connection issue. 1 Incorrect native library version: We use HIDAPI to access the Reliance Printer as a HID USB device. Our nuget package installs the native library for Windows(x86 and x64), Linux x64, ans OSX x64. If you use a different CPU or operating system, your environment is not supported at this time. Contact us! 2 Your operating system is not propagating device information in a standard way. This is common in Docker containers. If your system is supported and you've followed all the tutorials, read on to learn how to customize PTIRelianceLib for your environment. Options <xref:PTIRelianceLib.LibraryOptions> provides following properties: HidCleanupDelayMs: Used to ensure operating system is given enough time to remove and create device handles HidReconnectDelayMs: Used to give the operating system more time to enumerate devices during reconnection HidFlushStructuresOnEnumError: When no devices are found during enumeration, this may indicate stale device data is being forwarded by your system. Set this flag to force receipt of fresh information. Relation to Flash Update The Reliance Thermal Printer executes a reboot at the start and end of the flash update process. This generates USB disconnect and reconnect events which, as stated above, can be tricky on some systems. If you are having trouble flash updating for your system, take as look at some of the preconfigured settings available in <xref:PTIRelianceLib.LibraryOptions> such as DockerLinuxStretch. Warning Exceptions For clarity, exception handling has been elided. It is advisable to wrap any ReliancePrinter method calls in a try/catch block for <xref:PTIRelianceLib.PTIException>."
  }
}